---
title: "How Discord Stores Trillions of Messages"
slug: "how-discord-stores-messages"
summary: "A deep dive into Discord's message storage — from Cassandra to ScyllaDB."
publishedAt: "2026-01-28"
topic: "databases"
sourceUrl: "https://discord.com/blog/how-discord-stores-trillions-of-messages"
sourcePublisher: "Discord Engineering"
difficulty: "intermediate"
readTimeMinutes: 14
featured: true
readNext:
  - "what-is-a-database-really"
order: 1
---

## The Problem

Imagine you send a message in a Discord server with 500,000 members. That message needs to be stored, indexed, and retrievable — instantly. Now multiply that by every server on Discord, every channel, every DM, every day.

Discord handles **trillions** of messages. Not millions, not billions — trillions. And every single one needs to be searchable, loadable, and delivered in milliseconds.

<Callout type="info">
Discord processes over **4 billion messages per day**. That's roughly 46,000 messages per second, sustained, with spikes going much higher during peak hours.
</Callout>

## What They Started With: Cassandra

Discord originally chose **Cassandra** for message storage. Here's why that made sense at first:

<Definition term="Cassandra">
A distributed NoSQL database designed for high write throughput across many machines. Data is spread across a cluster of nodes, and any node can accept writes — there's no single "master" that becomes a bottleneck.
</Definition>

Cassandra gave Discord:
- **Linear scalability** — add more nodes, handle more messages
- **High write throughput** — every message is a write, and Discord has a LOT of writes
- **Tunable consistency** — they could choose speed over perfect consistency for chat messages

## Why Cassandra Broke Down

As Discord grew from millions to hundreds of millions of users, Cassandra started showing cracks:

1. **Read amplification** — fetching a channel's messages required reading from multiple partitions across multiple nodes
2. **Compaction storms** — Cassandra periodically merges data files (SSTables), and at Discord's scale, this caused latency spikes
3. **Garbage collection pauses** — Cassandra runs on the JVM, and GC pauses at this scale could freeze nodes for seconds

<Callout type="warning">
This is a pattern you'll see repeatedly in engineering blogs: a technology that works perfectly at one scale becomes a liability at the next order of magnitude. The tool didn't fail — the scale changed.
</Callout>

## The Migration to ScyllaDB

Discord migrated to **ScyllaDB**, which is architecturally similar to Cassandra but fundamentally different in implementation:

<Definition term="ScyllaDB">
A Cassandra-compatible database written in C++ instead of Java. It eliminates garbage collection pauses by managing memory directly, and uses a "shard-per-core" architecture where each CPU core handles its own subset of data independently.
</Definition>

The key improvements:

| Aspect | Cassandra | ScyllaDB |
|--------|-----------|----------|
| Language | Java (JVM, GC pauses) | C++ (no GC) |
| Threading | Shared threads | Shard-per-core |
| Latency | p99 ~200ms with spikes | p99 ~15ms stable |
| Compaction | Blocking, causes spikes | Concurrent, minimal impact |

## How Messages Are Actually Stored

```
channel_id → partition key
message_id → clustering key (sorted by time via Snowflake IDs)

Each partition = one channel's messages
Each row = one message
```

When you open a channel, Discord fetches the latest partition and reads the most recent messages by their clustering key. Older messages are loaded on scroll.

<Definition term="Partition Key">
The field that determines which node in the cluster stores a particular piece of data. All messages in the same channel share a partition key, so they're co-located on the same node — making channel reads fast.
</Definition>

<Figure caption="Simplified view of how Discord routes a message read request to the correct ScyllaDB node based on the channel's partition key.">
When you open #general in a large server:
1. Client sends request: "get latest messages for channel X"
2. API server hashes channel X's ID → determines which ScyllaDB node holds that partition
3. That node returns the latest rows from the partition
4. Messages are sent back to the client
</Figure>

<Takeaways>
- Discord stores trillions of messages across a distributed database cluster — no single machine holds everything
- They migrated from Cassandra to ScyllaDB because GC pauses and compaction storms became unacceptable at their scale
- The key trade-off was operational complexity (learning a new database) vs. performance reliability
- Messages are partitioned by channel — all messages in one channel live on the same node for fast reads
- This is an example of the "right tool for the right scale" principle — Cassandra wasn't wrong, they outgrew it
</Takeaways>
